# ğŸš€ 100 Days of Code â€“ Day 03

Today, I tackled two essential LeetCode problems to strengthen my understanding of arrays, hashing, and the sliding window technique.

---

## âœ… Problem 1: [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)
**Difficulty:** Easy  
**Language:** C++

### ğŸ” Problem Statement
Given an integer array `nums`, return `true` if any value appears **at least twice**, and `false` if every element is **distinct**.

### ğŸ’¡ Approach
- I used the **sorting** method.
- After sorting, duplicates (if any) will be adjacent.
- Compared each element with the next one.

### ğŸ§¾ Code Snippet
```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        for(int i = 0; i < nums.size() - 1; i++) {
            if(nums[i] == nums[i + 1]) return true;
        }
        return false;
    }
};

âœ… Problem 2: 121. Best Time to Buy and Sell Stock
Difficulty: Easy
Language: C++

ğŸ” Problem Statement
Find the maximum profit from a single buy and sell operation in a stock price array. You must buy before you sell.

ğŸ’¡ Approach (Sliding Window Technique)
Track the minimum price (buy) so far.
For each day, calculate profit: current_price - buy.
Update maximum profit accordingly.

ğŸ§¾ Code Snippet

class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int maxp = 0;
        int buy = prices[0];
        for(int i = 1; i < prices.size(); i++) {
            if(buy < prices[i]) {
                maxp = max(maxp, prices[i] - buy);
            }
            buy = min(buy, prices[i]);
        }
        return maxp;
    }
};

ğŸ“ˆ What I Learned
Efficient array iteration techniques.
Sorting as a tool to simplify duplicate detection.
Sliding window to optimize profit problems in O(n) time.

